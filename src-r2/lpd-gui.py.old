#!/usr/bin/env python3
"""
==============================================================================
Transformer Load Analysis GUI
==============================================================================
Author: Michal Czarnecki
Date:   11/26/2024
Version: 1.0

Description:
    This script provides a graphical user interface (GUI) for the Transformer 
    Load Analysis Tool. It allows users to select a CSV file containing load 
    data, input a transformer KVA size, and perform load analysis with 
    visualization. The tool integrates seamlessly with the `lpd-interactive.py` 
    backend script.

Usage:
    1. Run this script using Python 3:
       $ python lpd-gui.py
    2. Select an input CSV file containing load data.
    3. Enter a transformer KVA size (or 0 to skip transformer analysis).
    4. Optionally, enter a datetime in "YYYY-MM-DD HH:MM:SS" format.
    5. Click "Run Analysis" to generate results and visualizations.

Requirements:
    - Python 3.x
    - Required libraries: tkinter, subprocess, os, threading
==============================================================================
"""

import os
import tkinter as tk
from tkinter import filedialog, scrolledtext, messagebox
import subprocess
import threading
import sys
import datetime
import pandas as pd

DEBUG = False  # Set to True for debugging, False for production


class RedirectText:
    def __init__(self, text_widget):
        self.text_widget = text_widget

    def write(self, string):
        self.text_widget.insert(tk.END, string)
        self.text_widget.see(tk.END)

    def flush(self):
        pass


def round_to_nearest_15_minutes(dt):
    """Round a datetime object to the nearest 15-minute interval."""
    minute = (dt.minute + 7) // 15 * 15
    rounded_dt = dt.replace(minute=minute % 60, second=0, microsecond=0)
    if minute >= 60:
        rounded_dt += datetime.timedelta(hours=1)
    return rounded_dt


default_text = """                INSTRUCTIONS FOR USE
This program will run a load analysis profile for data in the input file.
Input CSV file is generated outside of this application and should be formatted:

Line 1: meter,date,time,kw
Line 2+: 85400796,2024-01-01,00:15:00.000,0.052

If transformer KVA is entered, a time-based transformer loading profile will 
be generated in the output along with a graph. (Single-phase only.)
If KVA = 0, transformer loading will be skipped in the output file, and no 
visualization will be available.
"""
default_kva = "75"
default_date = "2024-08-10 16:45:00"


def display_datetime_range(csv_file):
    """Read the CSV and display the first and last date in the output box."""
    try:
        df = pd.read_csv(csv_file, usecols=["date"])
        df["date"] = pd.to_datetime(df["date"], format="%Y-%m-%d", errors="coerce")
        first_date = df["date"].min()
        last_date = df["date"].max()

        output_textbox.insert(
            tk.END,
            f"\n"
            f"{'#' * 80}\n\n"
            f"{'File Loaded: ':<15}{os.path.basename(csv_file):<63}\n"
            f"{'Start Date: ':<15}{first_date.strftime('%Y-%m-%d'):<63}\n"
            f"{'End Date: ':<15}{last_date.strftime('%Y-%m-%d'):<63}\n\n"
            f"{'#' * 80}\n"
        )
        output_textbox.see(tk.END)
    except Exception as e:
        output_textbox.insert(tk.END, f"Error processing CSV: {e}\n")


def browse_file():
    """Open a file dialog to select a CSV file."""
    file_path = filedialog.askopenfilename(
        title="Select CSV File", filetypes=[("CSV Files", "*.csv"), ("All Files", "*.*")]
    )
    if file_path:
        csv_path_entry.delete(0, tk.END)
        csv_path_entry.insert(0, file_path)
        update_status("File selected successfully.", "success")

        display_datetime_range(file_path)


def save_arguments_to_file(csv_file, kva_value, datetime_value):
    """Save the arguments to a file."""
    try:
        args_file = "arguments.txt"
        with open(args_file, "w") as file:
            file.write(f'"{csv_file}" --transformer_kva {kva_value}')
            if datetime_value:
                file.write(f' --datetime "{datetime_value}"')
            file.write("\n")
    except Exception as e:
        print(f"An error occurred while saving arguments to file: {e}")


def launch_analysis(csv_file, kva_value, datetime_value=None):
    """Run analysis scripts sequentially."""
    try:
        update_status("Analysis started...", "success")
        clear_output_textbox()

        if not csv_file:
            update_status("Error: Please select a CSV file.", "error")
            return

        if not kva_value:
            update_status("Error: Please enter a transformer KVA size.", "error")
            return

        if datetime_value:
            try:
                if len(datetime_value.strip()) == 10:
                    datetime_value += " 00:00:00"
                elif len(datetime_value.strip()) == 19:
                    pass
            except ValueError:
                update_status("Error: Invalid datetime format.", "error")
                return

        save_arguments_to_file(csv_file, kva_value, datetime_value)

        os.chdir(os.path.dirname(__file__))

        # Define input_file and base correctly
        input_file = csv_file
        base, _ = os.path.splitext(input_file)
        base_command = [csv_file, "--transformer_kva", str(kva_value)]
        if datetime_value:
            base_command.extend(["--datetime", datetime_value.strip()])

        # Run lpd-main.py only if results are missing
        main_results_file = f"{base}_RESULTS.txt"
        if not os.path.exists(main_results_file):
            print(f"Running lpd-main.py to process load data for {input_file}")
            main_command = [sys.executable, "lpd-main.py"] + base_command
            subprocess.run(main_command, check=True)
        else:
            print(f"Skipping lpd-main.py: Results file '{main_results_file}' already exists.")


        # Run weather analysis only if the weather file is missing
        weather_file = f"{base}_WEATHER.csv"
        if not os.path.exists(weather_file):
            launch_weather_analysis()
        else:
            print(f"Skipping weather analysis: Weather file '{weather_file}' already exists.")

        # Check if weather file exists before merging
        if os.path.isfile(weather_file):
            merge_command = [sys.executable, "lpd-merge.py", csv_file]
            subprocess.run(merge_command, check=True)
        else:
            warning_message = (
                f"⚠️ Weather data file '{weather_file}' not found. Using '{load_profile_file}' as-is."
            )
            update_status(warning_message, "warning")

        # Check for final results file
        results_file = f"{base}_RESULTS.txt"
        if not os.path.isfile(results_file):
            print(f"Error: {results_file} not generated by lpd-main.py.")
            return

        # Display results
        if os.path.isfile(results_file):
            with open(results_file, "r") as file:
                clear_output_textbox()
                output_textbox.insert(tk.END, file.read())

        update_status("Analysis completed.", "success")

    except subprocess.CalledProcessError as e:
        print(f"Subprocess error: {e}")
    except Exception as e:
        print(f"An error occurred: {e}")


def launch_weather_analysis():
    """Launch lpd-weather.py with calculated parameters if weather_analysis_var is True."""
    if weather_analysis_var.get():
        try:
            csv_file = csv_path_entry.get()
            if not csv_file:
                update_status("⚠️ Please select a CSV file.", "error")
                return

            lpd_results = f"{os.path.splitext(csv_file)[0]}_RESULTS-LP.csv"
            df = pd.read_csv(lpd_results)

            if "datetime" not in df.columns:
                update_status(f"⚠️ Required column 'datetime' is missing in the results file.", "error")
                raise ValueError("Required column 'datetime' is missing in the results file.")

            df["datetime"] = pd.to_datetime(df["datetime"])
            min_datetime = df["datetime"].min()
            max_datetime = df["datetime"].max()
            start_date = min_datetime.strftime("%Y-%m-%d")
            end_date = max_datetime.strftime("%Y-%m-%d")

            zipcode = zipcode_entry.get().strip() or "84601"

            weather_command = [sys.executable, "lpd-weather.py", zipcode, start_date, end_date]
            subprocess.run(weather_command, check=True)
            update_status("Weather analysis completed.", "success")

        except Exception as e:
            update_status(f"⚠️Error during weather analysis: {e}", "error")

# Run merge only if weather analysis is performed or weather data exists
# weather_file = f"{os.path.splitext(csv_file)[0]}_WEATHER.csv"

# if os.path.isfile(weather_file):
    # merge_command = [sys.executable, "lpd-merge.py", csv_file]
    # subprocess.run(merge_command, check=True)
# else:
    # warning_message = (
        # f"⚠️ Weather data file '{weather_file}' not found. Using '{load_profile_file}' as-is."
    # )
    # update_status(warning_message, "warning")
    
# Run weather analysis only if the weather file is missing
weather_file = f"{base}_WEATHER.csv"
if not os.path.exists(weather_file):
    launch_weather_analysis()
else:
    print(f"Skipping weather analysis: Weather file '{weather_file}' already exists.")

# Check if weather file exists before merging
if os.path.isfile(weather_file):
    merge_command = [sys.executable, "lpd-merge.py", csv_file]
    subprocess.run(merge_command, check=True)
else:
    warning_message = (
        f"⚠️ Weather data file '{weather_file}' not found. Using '{load_profile_file}' as-is."
    )
    update_status(warning_message, "warning")



def clear_output_textbox():
    """Clear the output text box."""
    output_textbox.delete(1.0, tk.END)
    

def open_folder():
    """Open the folder where the input file is located."""
    csv_file = csv_path_entry.get()
    if not csv_file:
        update_status("Error: No file selected to open.", "error")
        return

    folder_path = os.path.dirname(csv_file)
    folder_path = os.path.normpath(folder_path)

    try:
        if os.name == "nt":
            subprocess.run(["explorer", folder_path], check=False)
        elif os.name == "posix":
            subprocess.run(["open" if sys.platform == "darwin" else "xdg-open", folder_path], check=False)
        update_status(f"Opened folder: {folder_path}", "success")

    except Exception as e:
        update_status(f"Error opening folder: {e}", "error")


def clear_all():
    """Clear all user inputs and outputs."""
    csv_path_entry.delete(0, tk.END)
    kva_entry.delete(0, tk.END)
    datetime_entry.delete(0, tk.END)
    clear_output_textbox()
    output_textbox.insert(tk.END, default_text)
    update_status("")


def update_status(message, status_type="info"):
    """Update the status label with a message."""
    colors = {"success": "green", "error": "red", "warning": "orange", "info": "black"}
    status_label.config(text=message, fg=colors.get(status_type, "black"))


def start_analysis_thread():
    """Start a background thread for the analysis."""
    csv_file = csv_path_entry.get()
    kva_value = kva_entry.get()
    datetime_value = datetime_entry.get()

    def run_analysis():
        try:
            launch_analysis(csv_file, kva_value, datetime_value)
        except Exception as e:
            update_status(f"Error during analysis: {e}", "error")

    threading.Thread(target=run_analysis, daemon=True).start()


# Create the main window
root = tk.Tk()
root.title("Load Profile Analysis")
root.resizable(False, False)

weather_analysis_var = tk.BooleanVar(value=True)

# Top Frame
top_frame = tk.Frame(root)
top_frame.grid(row=0, column=0, columnspan=6, pady=5, padx=5, sticky="ew")
tk.Label(top_frame, text="Select Input CSV File:").pack(side="left", padx=5)
csv_path_entry = tk.Entry(top_frame, width=45)
csv_path_entry.pack(side="left", padx=5)
tk.Button(top_frame, text="Browse...", command=browse_file).pack(side="left", padx=5)

# Full Load KVA
tk.Label(top_frame, text="Full load KVA:").pack(side="left", padx=5)
kva_entry = tk.Entry(top_frame, width=8)
kva_entry.insert(0, default_kva)
kva_entry.pack(side="left", padx=5)

# Row 1
row1_frame = tk.Frame(root)
row1_frame.grid(row=1, column=0, columnspan=6, pady=5, padx=5, sticky="ew")
tk.Label(row1_frame, text="Target (YYYY-MM-DD HH:MM:SS):").pack(side="left", padx=5)
datetime_entry = tk.Entry(row1_frame, width=19)
datetime_entry.insert(0, default_date)
datetime_entry.pack(side="left", padx=5)
tk.Label(row1_frame, text="ZIP Code:").pack(side="left", padx=5)
zipcode_entry = tk.Entry(row1_frame, width=5)
zipcode_entry.insert(0, "84601")
zipcode_entry.pack(side="left", padx=5)
tk.Checkbutton(row1_frame, text="Run Weather Analysis", variable=weather_analysis_var).pack(side="left", padx=5)

# Status Label
status_label = tk.Label(root, text="", anchor="w")
status_label.grid(row=2, column=0, columnspan=6, sticky="w", padx=5, pady=2)

# Output Textbox
output_textbox = scrolledtext.ScrolledText(root, width=85, height=20, wrap=tk.WORD)
output_textbox.grid(row=3, column=0, columnspan=6, padx=5, pady=5)
output_textbox.insert(tk.END, default_text)

# Bottom Buttons
button_frame = tk.Frame(root)
button_frame.grid(row=4, column=3, columnspan=3, pady=5, padx=5)
tk.Button(button_frame, text="Open Folder", command=open_folder).pack(side="left", padx=5)
tk.Button(button_frame, text="Run Analysis", command=start_analysis_thread).pack(side="left", padx=5)
tk.Button(button_frame, text="Clear All", command=clear_all).pack(side="left", padx=5)
tk.Button(button_frame, text="Close", command=root.destroy).pack(side="left", padx=5)

# Redirect standard output to the text box
output_redirector = RedirectText(output_textbox)
sys.stdout = output_redirector

# Run the main loop
root.mainloop()
